<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bucket Sort]]></title>
    <url>%2F2016%2F05%2F27%2FBucket-Sort%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//桶排序#include &lt;iostream&gt;using namespace std;struct Node&#123; int key; int next;&#125;;struct QueueNode&#123; int front; int rear;&#125;;void showw(Node r[],int n,int first)&#123; while(r[first].next != -1) &#123; cout &lt;&lt; r[first].key &lt;&lt; &quot; &quot;; first = r[first].next; &#125;&#125;void Distribute(Node r[],int n,QueueNode q[],int m,int first)&#123; int i = first; while( r[i].next != -1) //依次分配每一个待排序记录 &#123; int k = r[i].key; if(q[k].front == -1) q[k].front = i; //处理队列为空的情况 else r[q[k].rear].next = i; //在静态链表中实现插在队列尾部 q[k].rear = i; //修改队尾指针 i = r[i].next; //i后移，处理下一个记录 &#125; q[n].front = q[n].rear = i; //处理最后一个非空队列在静态链表中的下标 i = 0; while(r[i].next != -1 ) //处理仅出现一次的关键字在静态链表中的下标 &#123; int k = r[i].next; if(r[k].key != r[i].key) r[i].next = -1; i++; &#125; &#125;void Collect(Node r[],int n,QueueNode q[],int m , int &amp;first)&#123; int k = 0; while(q[k].front == -1) //找到第一个非空队列 k++; first = q[k].front; int last = q[k].rear; while(k &lt; m) &#123; k++; if(k &gt; m ) break; if(q[k].front != -1) &#123; r[last].next = q[k].front; last = q[k].rear; //cout &lt;&lt; last &lt;&lt; endl; &#125; &#125; r[last].next = -1;&#125;int BucketSort(Node r[],int n,const int m)&#123; int i; QueueNode q[m]; for (i = 0; i &lt; n; ++i) r[i].next = i+1; //初始化静态链表 r[n-1].next = -1; //设置尾标志 int first = 0; //设置头指针 for (i = 0; i &lt; m; ++i) q[i].front = q[i].rear = -1; Distribute(r,n,q,m,first); //进行分配 Collect(r,n,q,m,first); //进行收集，first指向的静态链表关键字最小下标 return first;&#125; void init(Node r[],int a[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; r[i].key = a[i]; &#125; &#125;int main()&#123; const int n = 12; const int m = 12; int a[n] = &#123;3,5,3,1,5,6,3,8,7,9,10&#125;; Node r[n+1]; init(r,a,n); //对node的值初始化 int first = BucketSort(r,n,m); showw(r,n,first); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meger Sort]]></title>
    <url>%2F2016%2F05%2F25%2FMeger-Sort%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//7.归并排序#include &lt;iostream&gt;#include &lt;sys/timeb.h&gt; using namespace std;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;void show(int r[],int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void Merge(int r[],int r1[],int s,int m ,int t)&#123; int i = s,j = m+1, k = s; while(i &lt;= m &amp;&amp; j &lt;= t) &#123; if(r[i] &lt;= r[j]) r1[k++] = r[i++]; else r1[k++] = r[j++]; &#125; if(i &lt;= m) while(i &lt;= m) r1[k++] = r[i++]; else while(j &lt;= t) r1[k++] = r[j++];&#125;void MergePass(int r[],int r1[], int n , int h)&#123; int i = 1; while(i &lt;= n-2*h+1) &#123; Merge(r,r1,i,i+h-1,i+2*h-1); i += 2*h; &#125; if(i &lt; n-h+1) Merge(r,r1,i,i+h-1,n); else for(int k=i;k&lt;=n;k++) r1[k] = r[k];&#125;void MergeSort(int r[],int r1[],int n)&#123; int h = 1; while(h &lt; n) &#123; MergePass(r,r1,n,h); h *= 2; MergePass(r1,r,n,h); h *= 2; &#125;&#125;void init(int r[],int n)&#123; for (int i = n; i &gt; 0; --i) &#123; r[i] = n-i; &#125; &#125;int main()&#123; const int n = 200000; // int r[n+1] = &#123;0,10,9,8,7,6,5,4,3,2,1&#125;; //第一个数据不存放 int r[n+1] = &#123;0,23,13,49,6,31,19,28&#125;; int r1[n+1]; init(r,n); struct timeb startTime , endTime; ftime(&amp;startTime); MergeSort(r,r1,n); ftime(&amp;endTime); cout &lt;&lt; &quot; 归并算法时间：：&quot; &lt;&lt; (endTime.time-startTime.time)*1000 + (endTime.millitm - startTime.millitm) &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; // show(r,n); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort]]></title>
    <url>%2F2016%2F05%2F22%2FQuicksort%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//3.快速排序#include &lt;iostream&gt;#include &lt;sys/timeb.h&gt; using namespace std;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;//一次划分算法int Partition(int r[],int first,int end)&#123; int i = first,j = end; while(i &lt; j) &#123; //右侧扫描,将轴值记录(i)与j指向的记录进行比较，如果j指向记录的关键码大，则j-- while(i &lt; j &amp;&amp; r[j] &gt;= r[i]) j--; if (i &lt; j) &#123; swap(r[i],r[j]); i++; &#125; //左侧扫描,将轴值记录(j)与i指向的记录进行比较，如果i指向记录的关键码小，则i++ while(i &lt; j &amp;&amp; r[i] &lt;= r[j]) i++; if (i &lt; j) &#123; swap(r[i],r[j]); j--; &#125; &#125; return i;&#125;void quickSort(int r[],int first,int end)&#123; if (first &lt; end) &#123; int pivot = Partition(r,first,end); quickSort(r,first,pivot-1); quickSort(r,pivot+1,end); &#125;&#125;void show(int r[],int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void init(int r[],int n)&#123; for (int i = n; i &gt; 0; --i) &#123; r[i] = n-i; &#125; &#125;int main()&#123; const int n = 200000; int r[n] = &#123;10,9,8,7,6,5,4,3,1,0&#125;; init(r,n);struct timeb startTime , endTime; ftime(&amp;startTime); quickSort(r,1,n); ftime(&amp;endTime); cout &lt;&lt; &quot; 算法运行时间：：&quot; &lt;&lt; (endTime.time-startTime.time)*1000 + (endTime.millitm - startTime.millitm) &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; //show(r,n); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell Sort]]></title>
    <url>%2F2016%2F05%2F20%2FShell-Sort%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//2.希尔排序#include &lt;iostream&gt;#include &lt;sys/timeb.h&gt; using namespace std;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;void show(int r[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void init(int r[],int n)&#123; for (int i = n; i &gt; 0; --i) &#123; r[i] = n-i; &#125; &#125; int main()&#123; const int n = 200000; int r[n] = &#123;10,9,8,7,6,5,4,3,1,0&#125;; init(r,n); struct timeb startTime , endTime; ftime(&amp;startTime); for(int d = n/2; d &gt;= 1; d /= 2) &#123; for (int i = d; i &lt; n; ++i) &#123; //从D+1开始插入 int temp = r[i]; int j; for(j = i-d;j&gt;=0 &amp;&amp; temp &lt; r[j]; j -= d) swap(r[j+d],r[j]); show(r,n); &#125; &#125; ftime(&amp;endTime); cout &lt;&lt; &quot; 算法运行时间：：&quot; &lt;&lt; (endTime.time-startTime.time)*1000 + (endTime.millitm - startTime.millitm) &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; //show(r,n); return 0; &#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search Tree]]></title>
    <url>%2F2016%2F05%2F12%2FBinary-Search-Tree%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//4.二叉排序树#include &lt;iostream&gt;using namespace std;struct BiNode&#123; int data; BiNode *lchild,*rchild; &#125;;void insert(BiNode *&amp;root,BiNode *s)&#123; if(root == NULL) root = s; else if(s-&gt;data &lt; root-&gt;data) insert(root-&gt;lchild,s); else insert(root-&gt;rchild,s);&#125;BiNode* BiSortTree(int r[],int n)&#123; BiNode* root = NULL; for (int i = 0; i &lt; n; ++i) &#123; BiNode* s = new BiNode; s-&gt;data = r[i]; s-&gt;lchild = NULL; s-&gt;rchild = NULL; insert(root,s); &#125; return root;&#125;/** 查找数据域为k的节点*@params p 指向要查找的数据域的指针p*@params par 指向p的双亲节点的引用*@params k 要查找的数据*@return 返回指向要查找的数据域的指针**/BiNode* search(BiNode* p,BiNode* &amp;par,int k)&#123; if(p == NULL) return NULL; else if(p-&gt;data == k) return p; else if(p-&gt;data &gt; k )&#123; par = p; return search(p-&gt;lchild,par,k); &#125; else if(p-&gt;data &lt; k )&#123; par = p; return search(p-&gt;rchild,par,k); &#125;&#125;void deleteNode(BiNode* p,BiNode* par)&#123; //1.若节点p是叶子，则直接删除节点p //2.若节点p只有左子树，则只需重连p的左子树 // 若节点p只有右子树，则只需重连p的右子树 //3.若节点p的左右子树均 不为空 // 3.1 查找节点p的右子树的最左下节点s(大于节点p的最小值) 以及节点s是双亲节点par(这样方便替换) // 3.2 将节点s的数据域替换到p的数据域 // 3.3 若节点p的右孩子无左子树(它是大于节点p的最小值)，则将s的右子树接到par的右子树上 // 否则，s的右子树接到par的左子树上 if(!p-&gt;lchild &amp;&amp; !p-&gt;rchild)&#123; if(par-&gt;lchild == p) par-&gt;lchild = NULL; else par-&gt;rchild = NULL; delete p; &#125; else if( !p-&gt;rchild)&#123; if(par-&gt;lchild == p) par-&gt;lchild = p-&gt;lchild; else par-&gt;rchild = p-&gt;lchild; delete p; &#125; else if( !p-&gt;lchild)&#123; if( par-&gt;lchild == p) par-&gt;lchild = p-&gt;rchild; else par-&gt;rchild = p-&gt;rchild; delete p; &#125; else&#123; par = p; BiNode* s = par-&gt;rchild; while( s-&gt;lchild) &#123; par = s; s = s-&gt;lchild; &#125; p-&gt;data = s-&gt;data; if( p == par) par-&gt;rchild = s-&gt;rchild; else par-&gt;lchild = s-&gt;lchild; &#125;&#125;//前序遍历二叉树void pre(BiNode* root)&#123; if(root == NULL) return; else &#123; cout &lt;&lt; root-&gt;data &lt;&lt; endl; pre(root-&gt;lchild); pre(root-&gt;rchild); &#125;&#125;int main()&#123; int s[10] = &#123;3,1,5,99,74,65,92,50,45,0&#125;; BiNode* root = BiSortTree(s,10); BiNode* ff = NULL; BiNode* f = search(root,ff,0); deleteNode(f,ff); pre(root); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键路径]]></title>
    <url>%2F2016%2F05%2F07%2F%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295//5.关键路径#include &lt;iostream&gt;using namespace std;const int MaxSize = 20;const int Offset = &apos;A&apos; - 0;struct ArcNode //边表节点&#123; int adjver; //邻接点域 int weight; //权值 ArcNode* next; &#125;;struct VertexNode&#123; int in; //入度 int out; //出度 int vertex; //点的 ArcNode* firstedge; //指向边表指针&#125;;/*邻接表构造函数*@params Graph 构建的图*@params v 顶点信息*@params vn 顶点数*@params e 边信息*@params en 边数*@params w 边对应的权值*/void ALGraph(VertexNode Graph[],int v[],int vn,int e[][2],int en,int w[])&#123; int i; for(i = 0; i &lt; vn;i++) //初始化邻接表，顶点信息赋值 &#123; Graph[i].vertex = v[i]; Graph[i].firstedge = NULL; &#125; //根据边信息完成邻接表 for (i = 0; i &lt; en; ++i) &#123; int ver = e[i][0]; int adjver = e[i][1]; ArcNode* s = new ArcNode; s-&gt;adjver = adjver; s-&gt;weight = w[i]; s-&gt;next = Graph[ver].firstedge; //头插法插入 Graph[ver].firstedge = s; &#125; //初始化每个点的入度和出度 for(i = 0; i &lt; vn;i++) &#123; int vertex = Graph[i].vertex; int in = 0; int j; //遍历所有点的邻接表，统计某个点的度 for(j = 0 ;j &lt; vn;j++) &#123; int out = 0; ArcNode * t = Graph[j].firstedge; while(t) &#123; out++; if(t-&gt;adjver == vertex) in++; t = t-&gt;next; &#125; Graph[j].out = out; &#125; Graph[i].in = in; &#125;&#125;//寻找到vk的最早发生时间int findMax(VertexNode Graph[],int k,int vn,int ve[])&#123; int i ; int max = 0; for(i = 0; i &lt; vn;i++) &#123; ArcNode* t = Graph[i].firstedge; while(t) &#123; if(t-&gt;adjver == k &amp;&amp; ve[Graph[i].vertex]+t-&gt;weight &gt; max) max = ve[Graph[i].vertex]+t-&gt;weight; t = t-&gt;next; &#125; &#125; return max;&#125;//求事件的最早发生时间void TopSort(VertexNode Graph[],int vn,int ve[])&#123; int s[MaxSize]; int top = -1; int count = 0; //扫描顶点表，将没有前驱的的顶点压入栈 int i; for(i = 0;i &lt; vn;i++) &#123; if(0 == Graph[i].in) s[++top] = Graph[i].vertex; &#125; ve[0] = 0; while(top &gt;= 0) &#123; //寻找到vk的最早发生时间 ve[s[top]] = findMax(Graph,s[top],vn,ve); count++; ArcNode* t = Graph[s[top]].firstedge; top--; //栈顶元素的所有邻接点度减一 while(t) &#123; //去度，加边 int k = t-&gt;adjver; Graph[k].in -= 1; //如果k入度为0，将点k入栈 if(Graph[k].in == 0) s[++top] = k; t = t-&gt;next; &#125; &#125; if(count &lt; vn) cout &lt;&lt; &quot;有回路&quot; &lt;&lt; endl;&#125;//求事件的最迟发生时间(逆向拓扑)void latestEven(VertexNode Graph[],int vn,int ve[],int vl[])&#123; int top = -1; int s[MaxSize]; //找出图中出度为0的点，加入栈中 int i; for(i = 0;i&lt; vn;i++) &#123; if(Graph[i].out == 0)&#123; s[++top] = Graph[i].vertex; &#125; &#125; //初始化vl vl[vn-1] = ve[vn-1]; while(top &gt;= 0) &#123; //cout &lt;&lt; s[top] &lt;&lt; endl; //1.弹出栈顶的点 int k = s[top--]; //找到到达点k的最小边对应的点 //看它有无邻接 ArcNode *tt = Graph[k].firstedge; int max = 0; int index = -1; while(tt) &#123; if(max &lt; tt-&gt;weight)&#123; index = tt-&gt;adjver; max = tt-&gt;weight; &#125; tt = tt-&gt;next; &#125; if(index != -1) vl[k] = vl[index] - max; //2.讲它的入度置为-1 Graph[k].out = -1; //3.遍历所有的点i，若点i的邻接点中存在k，则点i的出度减一 for(i = 0;i &lt; vn;i++) &#123; ArcNode * t = Graph[i].firstedge; while(t) &#123; if(t-&gt;adjver == k) &#123; Graph[i].out--; //4.判断点的出度是否为0,若为0，则该点入栈 if(Graph[i].out == 0) s[++top] = i; &#125; t = t-&gt;next; &#125; &#125; &#125;&#125;/**求每个活动发生的最早发生时间*@params ve 事件的最早发生时间*@params ee 活动的最早发生时间*@params en 活动的个数*@params e[][2] 活动与事件对应的关系矩阵*/void elyActivity(int ve[],int ee[],int en,int e[][2])&#123; //找到活动对应的起始事件 int i; for(i = 0; i &lt; en;i++) &#123; //顺序读取每个活动的起点 int k = e[i][0]; ee[i] = ve[k]; &#125;&#125;void latestAct(int vl[],int el[],int en,int e[][2],int w[])&#123; for(int i = 0; i &lt; en;i++) &#123; //顺序读取每个活动的终点 int k = e[i][1]; el[i] = vl[k] - w[i]; &#125;&#125;void findLoad(int e[][2],int en,int w[],int ve[],int vl[])&#123; cout &lt;&lt; &quot;该图的关键路径为：&quot; &lt;&lt; endl; int ee[MaxSize]; int el[MaxSize]; int i; for(i = 0;i &lt; 11; i++) &#123; int st = e[i][0]; ee[i] = ve[st]; int fi = e[i][1]; el[i] = vl[fi] - w[i]; if(ee[i] == el[i]) cout &lt;&lt; st &lt;&lt; &quot; &quot;; &#125;&#125;void show(VertexNode Graph[],int n)&#123; cout &lt;&lt; &quot;图结构如下：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;in &quot; &lt;&lt; &quot;v &quot; &lt;&lt; &quot;out &quot; &lt;&lt; &quot;&#123;Vi weight&#125;&quot; &lt;&lt; endl; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; Graph[i].in &lt;&lt; &quot; &quot;; cout &lt;&lt; Graph[i].vertex &lt;&lt; &quot; &quot;; cout &lt;&lt; Graph[i].out &lt;&lt; &quot; &quot;; ArcNode* t = Graph[i].firstedge; while(t) &#123; cout &lt;&lt; &quot;&#123;&quot;; cout &lt;&lt; t-&gt;adjver &lt;&lt; &quot; &quot;; cout &lt;&lt; t-&gt;weight &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;&#125; &quot;; t = t-&gt;next; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; //点 const int vn = 9; int v[vn] = &#123;0,1,2,3,4,5,6,7,8&#125;; const int en = 11; int e[en][2] = &#123;&#123;0,1&#125;,&#123;0,2&#125;,&#123;0,3&#125;, &#123;1,4&#125;,&#123;2,4&#125;, &#123;3,5&#125;, &#123;4,6&#125;,&#123;4,7&#125;, &#123;5,7&#125;, &#123;6,8&#125;,&#123;7,8&#125; &#125;; int w[11] = &#123;6,4,5, 1,1, 2, 9,7, 4, 2,4 &#125;; VertexNode Graph[MaxSize]; ALGraph(Graph,v,vn,e,en,w); show(Graph,vn); int ve[vn]; TopSort(Graph,vn,ve); int vl[vn]; latestEven(Graph,vn,ve,vl); findLoad(e,en,w,ve,vl); cout &lt;&lt; vn-1 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑序列]]></title>
    <url>%2F2016%2F05%2F04%2F%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//4.拓扑序列#include &lt;iostream&gt;using namespace std;const int MaxSize = 10;const int Offset = &apos;A&apos; - 0;struct ArcNode //边表节点&#123; char adjver; //邻接点域 ArcNode* next; &#125;;struct VertexNode&#123; int in; //入度 char vertex; //点的 ArcNode* firstedge; //指向边表指针&#125;;/*邻接表构造函数*@params Graph 构建的图*@params v 顶点信息*@params vn 顶点数*@params e 边信息*@params en 边数*/void ALGraph(VertexNode Graph[],char v[],int vn,int e[][2],int en)&#123; int i; for(i = 0; i &lt; vn;i++) //初始化邻接表，顶点信息赋值 &#123; Graph[i].vertex = v[i]; Graph[i].firstedge = NULL; &#125; //根据边信息完成邻接表 for (i = 0; i &lt; en; ++i) &#123; int ver = e[i][0]; int adjver = e[i][1]; ArcNode* s = new ArcNode; s-&gt;adjver = char(adjver+Offset); s-&gt;next = Graph[ver].firstedge; //头插法插入 Graph[ver].firstedge = s; &#125; //初始化每个点的度 for(i = 0; i &lt; vn;i++) &#123; char vertex = Graph[i].vertex; int sum = 0; int j; //遍历所有点的邻接表，统计某个点的度 for(j = 0 ;j &lt; vn;j++) &#123; ArcNode * t = Graph[j].firstedge; while(t) &#123; if(t-&gt;adjver == vertex) &#123; sum++; &#125; t = t-&gt;next; &#125; &#125; Graph[i].in = sum; &#125;&#125;void show(VertexNode Graph[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; Graph[i].in &lt;&lt; &quot; &quot;; cout &lt;&lt; Graph[i].vertex &lt;&lt; &quot; &quot;; ArcNode* t = Graph[i].firstedge; while(t) &#123; cout &lt;&lt; t-&gt;adjver &lt;&lt; &quot; &quot;; t = t-&gt;next; &#125; cout &lt;&lt; endl; &#125;&#125;void TopSort(VertexNode Graph[MaxSize],int vn)&#123; char s[MaxSize]; int top = -1; //扫描顶点表，将没有前驱的的顶点压入栈 int i; for(i = 0;i &lt; vn;i++) &#123; if(0 == Graph[i].in) s[++top] = Graph[i].vertex -Offset; &#125; int count = 0; while(top &gt;= 0) &#123; count++; cout &lt;&lt; Graph[s[top]].vertex &lt;&lt; endl; ArcNode* t = Graph[s[top]].firstedge; top--; //栈顶元素的所有邻接点度减一 while(t) &#123; //adjver是一个char类型的字符，减去偏移量得到顶点下标 int k = t-&gt;adjver - Offset; Graph[k].in -= 1; //k入度为0，将点k入栈 if(Graph[k].in == 0) s[++top] = k; t = t-&gt;next; &#125; &#125; if(count &lt; vn) cout &lt;&lt; &quot;有回路&quot; &lt;&lt; endl;&#125;int main()&#123; //假设有六个点 int vn = 6; char v[6] = &#123;&apos;A&apos; , &apos;B&apos; ,&apos;C&apos; , &apos;D&apos;, &apos;E&apos;,&apos;F&apos;&#125;; //他们的关系 int en = 9; int e[9][2] = &#123;&#123;1,0&#125;,&#123;1,3&#125;, &#123;2,0&#125;,&#123;2,3&#125;, &#123;3,0&#125;,&#123;3,5&#125;, &#123;4,2&#125;,&#123;4,3&#125;,&#123;4,5&#125;&#125;; VertexNode Graph[MaxSize]; ALGraph(Graph,v,vn,e,en); cout &lt;&lt; &quot;图结构：&quot; &lt;&lt; endl; show(Graph,vn); cout &lt;&lt; &quot; 拓扑序列：&quot; &lt;&lt; endl; TopSort(Graph,vn); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪杰斯特拉算法]]></title>
    <url>%2F2016%2F05%2F02%2F%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//最短路径#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;const int MAX = 999;const int MaxSize = 10;using namespace std;void MGraph(int arc[MaxSize][MaxSize])&#123; int n = 5; //存在这么一些点 int vertex[5] = &#123;0,1,2,3,4&#125;; //他们的关系 // int e[7][2] = &#123; &#123;0,1&#125; , &#123;1,3&#125; , &#123;3,4&#125; , &#123;4,2&#125;&#125;; // int [9][2] = &#123;&#123;0,1&#125;,&#123;0,2&#125;,&#123;0,5&#125;, // &#123;1,0&#125;,&#123;1,4&#125;, // &#123;2,0&#125;,&#123;2,3&#125;,&#123;2,5&#125;, // &#123;3,2&#125;,&#123;3,4&#125;,&#123;3,5&#125;, // &#123;4,1&#125;,&#123;4,3&#125;,&#123;4,5&#125;, // &#123;5,0&#125;,&#123;5,2&#125;,&#123;5,3&#125;,&#123;5,4&#125;&#125;; int e[7][2] = &#123;&#123;0,1&#125;,&#123;0,3&#125;,&#123;0,4&#125;, &#123;1,2&#125;,&#123;2,4&#125;,&#123;3,2&#125;,&#123;3,4&#125;&#125;; //他们对应的权值为 // int w[7] = &#123;9,6,5,4,7,3,8&#125;; int w[7] = &#123;10,30,100,50, 10,20,60&#125;; int i,j; for (i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n ;j++) if(i == j)&#123; arc[i][j] = 0; &#125;else arc[i][j] = MAX; &#125; //2.应用他们的关系构建矩阵 for ( i = 0; i &lt; 7; ++i) &#123; //扎到对应的点对应的边，并给他赋值 int row = e[i][0]; int col = e[i][1]; arc[row][col] = w[i]; &#125; &#125; void show(int arc[][MaxSize],int n) &#123; int i,j; for (i = 0; i &lt; n; ++i) &#123; for(j = 0;j &lt; n;j++) cout &lt;&lt; arc[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125;/**迪杰斯特拉最短路径*@params arc 储存有向图的邻接矩阵*@params n 顶点的个数*@params v 起始点(源点)*/int minEdge(int dist[],int vn)&#123; int min = 0; int i; //找到有效的第一个lowcost for(i = 1;i &lt; vn; i++) &#123; if(dist[i] != 0) &#123; min = i; break; &#125; &#125; for(i = 0;i &lt; vn; i++) &#123; if(dist[i] &gt; 0 &amp;&amp; (dist[min] &gt; dist[i])) min = i; &#125; return min;&#125;string getstring ( const int n )&#123; std::stringstream newstr; newstr &lt;&lt; n; return newstr.str();&#125;void Dijkstra(int arc[MaxSize][MaxSize],int vn,int v)&#123; int s[MaxSize]; //记录v到当前已经到达的点 int dist[MaxSize]; //记录v到vi的最短路径的长度 string path[MaxSize]; //记录v到vi的最短路径 //初始化dist数组 int i; for(i = 0; i &lt; vn;i++) &#123; dist[i] = arc[v][i]; if(arc[v][i] == MAX) path[i] = &quot;&quot;; else &#123; path[i] = getstring(v); path[i] += &quot; &quot;; path[i] += getstring(i); &#125; &#125; s[0] = v; dist[v] = 0; int j; for(i = 1;i &lt; vn; i++) &#123; //选出点v邻接边中权重最小的 int min = minEdge(dist,vn); //边加入s s[i] = min; //输出 cout &lt;&lt; path[min] &lt;&lt; &quot;-----&quot; &lt;&lt; dist[min] &lt;&lt; endl; //cout &lt;&lt; dist[min] &lt;&lt; endl; //从点min开始出发，如果v到它的权值加上它到vi的权值 小于 v直接到vi的权值，那么重写v到vi的最小权值，并记录路径 int j; for(j = 0;j &lt; vn; j++) &#123; if( arc[min][j] &gt; 0 &amp;&amp; dist[min] + arc[min][j] &lt;dist[j]) &#123; dist[j] = arc[min][j] + dist[min]; //path[j] = v + &quot; &quot; + min; //path[j] += &quot; &quot; + j; path[j] = getstring(v); path[j] += &quot; &quot;; path[j] += getstring(min); path[j] += &quot; &quot;; path[j] += getstring(j); &#125; &#125; //将该点记录为已走过 dist[min] = 0; &#125;&#125;int main()&#123; int arc[MaxSize][MaxSize]; int n = 5; MGraph(arc); cout &lt;&lt; &quot;图结构：&quot; &lt;&lt; endl; show(arc,n); cout &lt;&lt; endl; cout &lt;&lt; &quot;最短路径：&quot; &lt;&lt; endl; Dijkstra(arc,n,0); return 0;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[haff-tree]]></title>
    <url>%2F2016%2F04%2F25%2Fhaff-tree%2F</url>
    <content type="text"><![CDATA[问题：建立哈夫曼树，并能够对输入的英文字符串进行编码，对编码后字符串进行译码。分析：问题包含两个部分，即：1.编码 1.1.得到一个字符串，计算每个字符出现的频度，建立字典&lt;字符，频度&gt; 1.2.根据字典，建立哈夫曼树，字典的字符为树节点的数据，频度为节点的权值 1.3.根据哈夫曼树求得每个字符的编码 1.3.1.获得一个字符，找到该字符在哈夫曼树种对应的叶子节点 1.3.2.从该叶子节点出发，一直回溯至根节点，获得一串反向的哈夫曼编码 1.3.3.将该编码翻转，得到字符对应的正确的哈夫曼编码2.译码 2.1.得到一个哈夫曼编码串和对应的哈夫曼树 2.2.根据哈夫曼树反编译编码串，得到原明文字符串 2.2.1.获得一个哈夫曼编码串，遍历该编码串 2.2.1.1.从根节点出发，循环读取哈夫曼字符串，根据读取字符的值 移动指针一直至叶子节点 2.2.1.2.获得该叶子节点的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;const int MAX_VALUE = 100000; //哈夫曼节点权值上限，用于比较const int MAX_SIZE = 10000; //哈夫曼树数组长度struct element&#123; char data; int weight; int lchild,rchild,parent;&#125;;void toDic(string content,map&lt;char,int &gt; &amp;g_DIC); //字符记数void Select(element huffTree[],int n,int &amp;i1,int &amp;i2); //查找权值最小void huffmanTree(element huffTree[],map&lt;char,int&gt; dic,int n); //构建哈夫曼树string reveres(string content); //字符串翻转/*单个字符哈夫曼编码*@params huffTree 完成构建的哈夫曼树*@params data 需要编码的字符*@params n 哈夫曼树的叶子数*@return 字符对应的哈夫曼编码*/string code_one(element huffTree[],char data,int n); /*哈夫曼编码串译码*@params huffTree 完成构建的哈夫曼树*@params root 哈夫曼树根节点的下标*@params huff_code 需要译码的哈夫曼编码串*@return 译码后的原明文字符串*/string decode(element huffTree[],int root,string haff_code); //void show(element huffTree[],int n); //显示哈夫曼树int main()&#123; cout &lt;&lt; &quot;请输入一串英文字符串(vc6.0下输入完成后请按两次回车)：&quot;&lt;&lt; endl; string content; getline(cin,content); map&lt;char,int&gt; dic; toDic(content,dic); //计算字符频度并存入字典 int n = dic.size(); element huffTree[MAX_SIZE]; huffmanTree(huffTree,dic,n); //根据字典生成哈夫曼树 cout &lt;&lt; &quot;哈夫曼树：&quot; &lt;&lt; endl; show(huffTree,2*n-1); //显示哈夫曼树 string code; int i = 0; while(content[i] != &apos;\0&apos;) &#123; code += code_one(huffTree,content[i],n);//字符串编码 i++; &#125; cout &lt;&lt; &quot;哈夫曼编码：&quot; &lt;&lt; endl; cout &lt;&lt; code &lt;&lt; endl; cout &lt;&lt; &quot;请输入一串哈夫曼编码：&quot; &lt;&lt; endl;; cin &gt;&gt; code; cout &lt;&lt; &quot;其明文：&quot;; cout &lt;&lt; decode(huffTree,2*n-2,code) &lt;&lt; endl;//字符串解码&#125;//字符记数函数void toDic(string content,map&lt;char,int &gt; &amp;g_DIC)&#123; int i = 0; map &lt;char, int&gt;::iterator iter; while(content[i] != &apos;\0&apos;) &#123; iter = g_DIC.find(content[i]); if(iter == g_DIC.end()) g_DIC.insert(pair&lt;int,char&gt;( content[i], 1)); else iter-&gt;second += 1; i++; &#125;&#125; void show(element huffTree[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; huffTree[i].data &lt;&lt; &quot; &quot;; cout &lt;&lt; huffTree[i].weight &lt;&lt; &quot; &quot;; cout &lt;&lt; huffTree[i].parent &lt;&lt; &quot; &quot;; cout &lt;&lt; huffTree[i].lchild &lt;&lt; &quot; &quot;; cout &lt;&lt; huffTree[i].rchild &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;&#125;void Select(element huffTree[],int n,int &amp;i1,int &amp;i2)&#123; int w1 = MAX_VALUE,w2 = MAX_VALUE; //w1,w2为权重最小的两个节点的权值,用于临时比较 for (int i = 0; i &lt; n; ++i) &#123; if(huffTree[i].parent == -1) &#123; if (w1 &gt; huffTree[i].weight) &#123; i2 = i1; //当发现一个新的最小数，此时i1下标即为第二小的数 w2 = w1; w1 = huffTree[i].weight; i1 = i; &#125; else if(w2 &gt; huffTree[i].weight) &#123; w2 = huffTree[i].weight; i2 = i; &#125; &#125; &#125;&#125;//构建哈夫曼树void huffmanTree(element huffTree[],map&lt;char,int&gt; dic,int n)&#123; int i= 0; for ( i = 0; i &lt; 2*n-1; ++i) //初始化，所有的节点均没有双亲和孩子 &#123; huffTree[i].parent = -1; huffTree[i].lchild = -1; huffTree[i].rchild = -1; &#125; i = 0; map &lt;char, int&gt;::iterator iter; for(iter = dic.begin(); iter != dic.end(); iter++) //从字典中取出字符和其对应的权重,构造n课只含有根节点的二叉树 &#123; huffTree[i].data = iter-&gt;first; huffTree[i].weight = iter-&gt;second; i++; &#125; for(int k = n;k &lt; 2*n-1;k++) &#123; int i1,i2; Select(huffTree,k,i1,i2); //查找权值最小的两个根节点，下标为i1,i2,比较的范围为0到k huffTree[i1].parent = k; //将i1,i2合并，且它们的双亲为k huffTree[i2].parent = k; huffTree[k].weight = huffTree[i1].weight + huffTree[i2].weight; huffTree[k].lchild = i1; huffTree[k].rchild = i2; &#125;&#125;//字符串翻转string reveres(string content)&#123; int length = 0; while(content[length++] != &apos;\0&apos;); for (int i = 0 , j = length-2; i &lt;= j; i++,j--) &#123; char temp = content[i]; content[i] = content[j]; content[j] = temp; &#125; return content;&#125;string code_one(element huffTree[],char data,int n)&#123; string result; for (int i = 0; i &lt; n; ++i) &#123; if(data == huffTree[i].data) //首先找到该字符在哈夫曼树中对应的叶子节点 &#123; //从叶子节点出发，一直到根节点，获取其反向的哈夫曼编码 int c = i; int p = huffTree[c].parent; while(p != -1) //一直回溯到根节点 &#123; if(c == huffTree[p].lchild) result += &apos;0&apos;; else result += &apos;1&apos;; c = p; //节点指针上移 p = huffTree[p].parent; &#125; &#125; &#125; return reveres(result); //返回翻转后的哈夫曼编码&#125; string decode(element huffTree[],int root,string haff_code)&#123; int i = 0; int cur = root; string result; while(haff_code[i] != &apos;\0&apos;) &#123; while(huffTree[cur].lchild != -1 &amp;&amp; huffTree[cur].rchild != -1) &#123; if(haff_code[i] == &apos;0&apos;) cur = huffTree[cur].lchild; else cur = huffTree[cur].rchild; //跳到编码串的下一个字符 i++; &#125; //得到一个字符 result += huffTree[cur].data; //重置当前下标位置为根节点 cur = root; &#125; return result;&#125;]]></content>
      <tags>
        <tag>Date Structure and algorithm</tag>
      </tags>
  </entry>
</search>